<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>simpla-behavior</title>
    <script src="../../web-component-tester/browser.js"></script>

    <!-- Import WC polyfills -->
    <script src="/bower_components/webcomponentsjs/custom-elements-es5-adapter.js"></script>
    <script src="/bower_components/webcomponentsjs/webcomponents-loader.js"></script>

    <!-- Import Simpla -->
    <script src="/node_modules/simpla/simpla.min.js"></script>
    <script> Simpla.init({})</script>

    <!-- Import the element to test -->
    <link rel="import" href="../simpla-element-behavior.html">
  </head>
  <body>
    <script>
      const wait = (delay = 5) => () => new Promise(resolve => setTimeout(resolve, delay)),
            randomString = () => Math.random().toString(36).slice(0,5),
            waitForLoaded = (element) => new Promise(resolve => {
              function handler(event) {
                if (event.detail.value) {
                  resolve();
                  element.removeEventListener('loaded-changed', handler);
                }
              };

              element.addEventListener('loaded-changed', handler);
            });

      function defineComponent(config, base) {
        const Component = class extends window.SimplaElement(HTMLElement) {
          static get simplaConfig() {
            return config;
          }
        }

        customElements.define(`test-component-${randomString()}`, Component);

        return Component;
      }

      function fire(on, name) {
        on.dispatchEvent(new CustomEvent(name));
      }

      describe('simpla-behavior', () => {
        let path = '/some-path';

        beforeEach(() => {
          return Simpla.set(path, { data: {} });
        });

        describe('basic functionality', () => {
          let config = {
                type: 'Component',
                dataProperties: [ 'meta' ],
                events: [ 'change' ]
              },
              Component,
              component;

          beforeEach(() => {
            Component = defineComponent(config);
            component = new Component();
            component.path = path;
            document.body.appendChild(component);
            
            return waitForLoaded(component);
          });

          afterEach(() => {
            component.parentElement.removeChild(component);
          });

          it('should set with given type', () => {
            component.meta = { foo: 'bar' };
            fire(component, 'change');

            return Promise.resolve()
              .then(wait())
              .then(() => {
                return Simpla.get(path)
              })
              .then(response => {
                expect(response.type).to.equal(config.type);
              });
          });

          it('should set property value to Simpla', () => {
            return Promise.resolve()
              .then(() => {
                component.meta = { foo: 'bar' };
                fire(component, 'change');            
              })
              .then(wait())
              .then(() => Simpla.get(path))
              .then(response => {
                expect(response.data.meta).to.deep.equal(component.meta);
              })
          });

          it('should get property value from Simpla', () => {
            let meta = { foo: 'bar' };

            return Promise.resolve()
              .then(() => Simpla.set(path, { data: { meta } }))
              .then(wait())
              .then(() => {
                expect(component.meta).to.deep.equal(meta);
              });
          });

          it('should not observe path while detached from DOM', () => {
            let unattached = new Component(),
                meta = { foo: 'bar' };

            unattached.path = path;
            return Promise.resolve()
              .then(() => Simpla.set(path, { data: { meta } }))
              .then(wait())
              .then(() => {
                expect(unattached.meta).to.not.deep.equal(meta);
              });
          });

          it('should update content when path changes', () => {
            let secondaryPath = '/path-b',
                secondaryMeta = { some: 'value' };

            return Promise.resolve()
              .then(() => Simpla.set(secondaryPath, { data: { meta: secondaryMeta } }))
              .then(() => component.path = secondaryPath)
              .then(wait())
              .then(() => {
                expect(component.meta).to.deep.equal(secondaryMeta);
              })
          });

          it('should not set to buffer while disconnected from DOM', () => {
            let detachedComponent = new Component(),
                meta = randomString();

            detachedComponent.path = path;
            detachedComponent.meta = meta;
            fire(component, 'change');
            
            return Promise.resolve()
              .then(wait())
              .then(() => Simpla.get(path))
              .then(item => {
                expect(item.data.meta).to.not.equal(meta);
              });
          });

          it('should not set to buffer before initial content loaded', () => {
            let unloadedComponent = new Component(),
                original = { meta: 'some-value' };

            return Simpla.set(path, { data: original })
              .then(() => {
                document.body.appendChild(unloadedComponent);
                unloadedComponent.path = path;
                unloadedComponent.meta = 'another-value';
                fire(component, 'change');            
              })
              .then(wait())
              .then(() => Simpla.get(path))
              .then(item => {
                expect(unloadedComponent.meta).to.deep.equal(original.meta);
                expect(item.data).to.deep.equal(original);
              });


          });

          it('should follow Simplas editable state', () => {
            component.editable = false;

            return Promise.resolve()
              .then(() => Simpla.editable(true))
              .then(wait())
              .then(() => {
                expect(component.editable).to.be.true;
              });
          });

          it('should not update data if path changed mid-request', () => {
            let itemA = { path: '/path-a', data: { text: 'foo' } },
                itemB = { path: '/path-b', data: { text: 'bar' } },
                calledWithPaths = [],
                waitForSetup;

            waitForSetup = Promise.all([
              Simpla.set(itemA.path, itemA),
              Simpla.set(itemB.path, itemB)
            ]).then(([ responseA, responseB ]) => {
              itemA = responseA;
              itemB = responseB;
            });

            // This is a hack, can't seem to stub methods on a prototype
            // and component.updateFromSimpla = sinon.stub() appears to 
            // have the same broken behavior
            component.updateFromSimpla = item => {
              calledWithPaths.push(item.path);
            }
            
            return Promise.resolve()
              .then(() => waitForSetup)
              .then(() => {
                component.path = itemA.path;
                component.path = itemB.path;
              })
              .then(wait())
              .then(() => {
                expect(calledWithPaths).to.not.contain(itemA.path);
                expect(calledWithPaths).to.contain(itemB.path);
              });
          });

          it('should not set back to simpla during load from simpla', () => {
            let Component = defineComponent({
                  type: 'Component',
                  dataProperties: [ 'text' ],
                  events: [ 'change' ]
                }),
                component = new Component();

            component.path = path;
            document.body.appendChild(component);

            component.updateSimplaBuffer = sinon.stub();

            // Setup setters / getters to re-trigger a change
            Object.defineProperty(component, 'text', {
              set(value) {
                this._text = value;
                fire(this, 'change');
              },

              get(value) {
                return this._text;
              }
            });

            return Promise.resolve()
              .then(() => Simpla.set(path, { data: { text: 'Hello World' } }))
              .then(wait())
              .then(() => {
                expect(component.updateSimplaBuffer.called).to.be.false;
              });
          });          

          describe('readonly', () => {
            it('should not follow editable if readonly true', () => {
              component.readonly = true;

              return Promise.resolve()
                .then(() => Simpla.editable(true))
                .then(wait())
                .then(() => {
                  expect(component.editable).to.be.false;
                });
            });

            it('should go uneditable if readonly is set', () => {
              component.editable = true;
              expect(component.editable).to.be.true;
              component.readonly = true;
              expect(component.editable).to.be.false;
            });

            it('should restore editable state if readonly is removed', () => {
              component.readonly = true;

              return Promise.resolve()
                .then(() => Simpla.editable(true))
                .then(wait())
                .then(() => {
                  component.readonly = false;
                  expect(component.editable).to.be.true;
                });
            });

            it('should bail from editable if readonly true', () => {
              component.readonly = true;
              component.editable = true;
              expect(component.editable).to.be.false;
            });
          });
          
        });

        describe('preventing infinite loops', () => {
          
        });

        describe('static-content', () => {
          let path = '/static-content',
              component;

          beforeEach(() => {
            let Component = defineComponent(
              { type: 'Component', dataProperties: [ 'text' ], events: [ 'change' ] }
            );

            component = new Component();
            component.text = 'Some static content';

            document.body.appendChild(component);

            Simpla.editable(false);
          });

          afterEach(() => {
            component.parentElement.removeChild(component);
          });

          it(`should set content into the buffer if no content is available`, () => {
            component.path = path;

            return waitForLoaded(component)
              .then(() => Simpla.get(path))
              .then((content) => {
                expect(content.data.text).to.equal(component.text);
              });
          });

          it(`should not set it's own content to the buffer if data exists`, () => {
            let text = 'Hello World';

            return Simpla.set(path, { data: { text } })
              .then(wait())
              .then(() => component.path = path)
              .then(() => Simpla.get(path))
              .then((content) => {
                expect(content.data.text).to.equal(text);
              });
          });
        });
      });
    </script>
  </body>
</html>
