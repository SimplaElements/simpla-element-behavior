<script>'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var DEFAULT_CONFIG = {
  get: '_updateFromSimpla',
  set: '_updateSimplaBuffer',
  updateOn: []
},
    ERRORS = {
  NO_SIMPLA: 'Cannot find Simpla, ensure it is included before this component'
};

window.SimplaBehaviors = window.SimplaBehaviors || {};

SimplaBehaviors.Element = function (config) {
  var _Object$assign = _extends({}, DEFAULT_CONFIG, config),
      type = _Object$assign.type,
      getCallback = _Object$assign.get,
      setCallback = _Object$assign.set,
      dataProperties = _Object$assign.dataProperties,
      updateOn = _Object$assign.updateOn,
      listeners = void 0,
      observers = void 0;

  var propsToObservers = function propsToObservers(prop) {
    return '_protectedSetCallback(' + prop + ')';
  },
      eventsToListeners = function eventsToListeners(listeners, event) {
    return _extends(listeners, _defineProperty({}, event, '_protectedSetCallback'));
  };

  return {
    properties: {
      /**
       * Simpla content path
       * @type {String}
       */
      path: {
        type: String,
        observer: '_initPathIfReady'
      },

      /**
       * Whether element is editable
       * @type {Boolean}
       */
      editable: {
        type: Boolean,
        notify: true
      },

      /**
       * Whether content is loaded
       * @type {Boolean}
       */
      loaded: {
        type: Boolean,
        readOnly: true,
        notify: true,
        value: false
      },

      /**
       * Stored Simpla observers
       * @type {Object}
       */
      __simplaObservers: {
        type: Object,
        value: function value() {
          return {};
        }
      }
    },

    listeners: updateOn.reduce(eventsToListeners, {}),

    observers: dataProperties.map(propsToObservers),

    /**
     * Check for Simpla on element creation
     * @return {undefined}
     */
    created: function created() {
      if (!window.Simpla) {
        throw new Error(ERRORS.NO_SIMPLA);
      }
    },


    /**
     * Setup editable state observer on attach
     * @return {undefined}
     */
    attached: function attached() {
      this._attached = true;

      // Setup editable property
      this.editable = this.editable || Simpla.getState('editable');
      this._observeSimplaEditable();

      // Try set up path observer
      this._initPathIfReady(this.path);
    },


    /**
     * Clean up Simpla observers on detach
     * @return {undefined}
     */
    detached: function detached() {
      var _this = this;

      Object.keys(this.__simplaObservers).forEach(function (observer) {
        _this.__simplaObservers[observer].unobserve();
      });

      this.__simplaObservers = {};
    },


    /**
     * Checks if attached and has a valid path. If so, calls _initSimplaPath
     * @param  {String} path Current value of path prop
     * @return {undefined}
     */
    _initPathIfReady: function _initPathIfReady(path) {
      if (this._attached && (typeof path === 'undefined' ? 'undefined' : _typeof(path)) !== undefined) {
        this._initSimplaPath(path);
      }
    },


    /**
     * Init the path observer
     * @param  {String} path Current value of path prop
     * @return {undefined}
     */
    _initSimplaPath: function _initSimplaPath(path) {
      var _this2 = this;

      this._setLoaded(false);

      Simpla.get(path).then(function (item) {
        var isEmpty = !(item && item.data),
            pathChanged = _this2.path !== item.path;

        if (pathChanged) {
          return;
        }

        if (isEmpty) {
          // Load static content
          _this2._protectedSetCallback();
        } else {
          _this2._protectedGetCallback(item);
        }

        _this2._setLoaded(true);
      });

      this._observeSimplaBuffer(path);
    },


    /**
     * Observe buffer for changes to update element
     * @param  {String} path Path to observe in buffer
     * @return {undefined}
     */
    _observeSimplaBuffer: function _observeSimplaBuffer(path) {
      var _this3 = this;

      var observers = this.__simplaObservers;

      if (!path) {
        return;
      }

      if (observers.buffer) {
        observers.buffer.unobserve();
      }

      observers.buffer = Simpla.observe(path, function (item) {
        if (item && item.data) {
          _this3._protectedGetCallback(item);
        }
      });
    },


    /**
     * Sets up the data property to send to Simpla based on given dataProperties
     * @return {Object}  Data to set to Simpla
     */
    _updateSimplaBuffer: function _updateSimplaBuffer() {
      var _this4 = this;

      return dataProperties.reduce(function (data, prop) {
        return _extends(data, _defineProperty({}, prop, _this4[prop]));
      }, {});
    },


    /**
     * Update element from Simpla data
     * @param  {Object} item The data from Simpla to update with
     * @return {undefined}
     */
    _updateFromSimpla: function _updateFromSimpla(item) {
      _extends(this, item.data);
    },


    /**
     * Calls the getCallback but protects against triggering an infinite loop
     * @param  {Object} item Item to give to getCallback
     * @return {undefined}
     */
    _protectedGetCallback: function _protectedGetCallback(item) {
      this.__loadingFromSimpla = true;
      this[getCallback](item);
      this.__loadingFromSimpla = false;
    },


    /**
     * Calls the setCallback but protects against triggering an infinite loop
     * @return {undefined}
     */
    _protectedSetCallback: function _protectedSetCallback() {
      if (!this.__loadingFromSimpla && this.path) {
        var data = this[setCallback]();

        Simpla.set(this.path, { type: type, data: data });
      }
    },


    /**
     * Editable state observer
     * @return {undefined}
     */
    _observeSimplaEditable: function _observeSimplaEditable() {
      var _this5 = this;

      var observers = this.__simplaObservers;

      if (observers.editable) {
        observers.editable.unobserve();
      }

      observers.editable = Simpla.observeState('editable', function (editable) {
        _this5.editable = editable;
      });
    }
  };
};</script>
