<script>'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function changed(from, prop, value) {
  from.dispatchEvent(new CustomEvent(prop + '-changed', { detail: { value: value } }));
}

var ERRORS = {
  NO_SIMPLA: 'Cannot find Simpla, ensure it is included before this component'
};

window.SimplaElement = function (Base) {
  return function (_Base) {
    _inherits(_class, _Base);

    function _class() {
      _classCallCheck(this, _class);

      var _this = _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).call(this));

      if (!window.Simpla) {
        throw new Error(NO_SIMPLA);
      }

      _this._loaded = false;
      _this.__simplaObservers = {};
      _this.__triggerBufferSync = function () {
        if (_this.loaded) {
          _this._protectedSetCallback();
        }
      };
      return _this;
    }

    _createClass(_class, [{
      key: 'attributeChangedCallback',
      value: function attributeChangedCallback(attr, oldValue, newValue) {
        if (attr === 'path') {
          this.path = newValue;
        } else {
          // Cast as Boolean. 
          this[attr] = newValue !== null;
        }
      }

      /**
       * Setup editable state observer on attach
       * @return {undefined}
       */

    }, {
      key: 'connectedCallback',
      value: function connectedCallback() {
        var _this2 = this;

        var events = this.constructor.simplaConfig.events;


        _get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'connectedCallback', this) && _get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'connectedCallback', this).call(this);

        events.forEach(function (event) {
          return _this2.addEventListener(event, _this2.__triggerBufferSync);
        });

        this.editable = this.readonly ? false : this.editable || Simpla.getState('editable');

        this._observeSimplaEditable();
        this._initPathIfReady(this.path);
      }

      /**
       * Clean up Simpla observers on detach
       * @return {undefined}
       */

    }, {
      key: 'disconnectedCallback',
      value: function disconnectedCallback() {
        var _this3 = this;

        var events = this.constructor.simplaConfig.events;


        _get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'disconnectedCallback', this) && _get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'disconnectedCallback', this).call(this);

        events.forEach(function (event) {
          return _this3.removeEventListener(event, _this3.__triggerBufferSync);
        });

        Object.keys(this.__simplaObservers).forEach(function (observer) {
          _this3.__simplaObservers[observer].unobserve();
        });

        this.__simplaObservers = {};
      }

      /**
       * Checks if connected and has a valid path. If so, calls _initSimplaPath
       * @param  {String} path Current value of path prop
       * @return {undefined}
       */

    }, {
      key: '_initPathIfReady',
      value: function _initPathIfReady(path) {
        if (this.isConnected && typeof path !== 'undefined') {
          this._initSimplaPath(path);
        }
      }

      /**
       * Init the path observer
       * @param  {String} path Current value of path prop
       * @return {undefined}
       */

    }, {
      key: '_initSimplaPath',
      value: function _initSimplaPath(path) {
        var _this4 = this;

        this._loaded = false;

        Simpla.get(path).then(function (item) {
          var isEmpty = !(item && item.data),
              pathChanged = _this4.path !== path,
              buffer = Simpla.getState('buffer'),
              bufferIsClean = buffer && buffer[path] && !buffer[path].modified;

          if (pathChanged) {
            return;
          }

          if (isEmpty && bufferIsClean) {
            // Load static content
            _this4._protectedSetCallback().then(function () {
              _this4._loaded = true;
            });
          } else {
            _this4._protectedGetCallback(item);
            _this4._loaded = true;
          }
        });

        this._observeSimplaBuffer(path);
      }

      /**
       * Observe buffer for changes to update element
       * @param  {String} path Path to observe in buffer
       * @return {undefined}
       */

    }, {
      key: '_observeSimplaBuffer',
      value: function _observeSimplaBuffer(path) {
        var _this5 = this;

        var observers = this.__simplaObservers;

        if (!path) {
          return;
        }

        if (observers.buffer) {
          observers.buffer.unobserve();
        }

        observers.buffer = Simpla.observe(path, function (item) {
          if (item && item.data) {
            _this5._protectedGetCallback(item);
          }
        });
      }

      /**
       * Sets up the data property to send to Simpla based on given dataProperties
       * @return {Object}  Data to set to Simpla
       */

    }, {
      key: 'updateSimplaBuffer',
      value: function updateSimplaBuffer() {
        var _this6 = this;

        var dataProperties = this.constructor.simplaConfig.dataProperties;


        return dataProperties.reduce(function (data, prop) {
          return _extends(data, _defineProperty({}, prop, _this6[prop]));
        }, {});
      }

      /**
       * Update element from Simpla data
       * @param  {Object} item The data from Simpla to update with
       * @return {undefined}
       */

    }, {
      key: 'updateFromSimpla',
      value: function updateFromSimpla(item) {
        _extends(this, item.data);
      }

      /**
       * Calls the getCallback but protects against triggering an infinite loop
       * @param  {Object} item Item to give to getCallback
       * @return {undefined}
       */

    }, {
      key: '_protectedGetCallback',
      value: function _protectedGetCallback(item) {
        this.__loadingFromSimpla = true;
        this.updateFromSimpla(item);
        this.__loadingFromSimpla = false;
      }

      /**
       * Calls the setCallback but protects against triggering an infinite loop
       * @return {undefined}
       */

    }, {
      key: '_protectedSetCallback',
      value: function _protectedSetCallback() {
        var done = Promise.resolve();
        if (!this.__loadingFromSimpla && this.isConnected && this.path) {
          var data = this.updateSimplaBuffer(),
              type = this.constructor.simplaConfig.type;


          if (typeof data !== 'undefined' || data === null) {
            done = Simpla.set(this.path, { type: type, data: data });
          }
        }

        return done;
      }

      /**
       * Editable state observer
       * @return {undefined}
       */

    }, {
      key: '_observeSimplaEditable',
      value: function _observeSimplaEditable() {
        var _this7 = this;

        var observers = this.__simplaObservers;


        if (observers.editable) {
          observers.editable.unobserve();
        }

        observers.editable = Simpla.observeState('editable', function (editable) {
          _this7.editable = editable;
        });
      }
    }, {
      key: 'path',
      get: function get() {
        return this.__path;
      },
      set: function set(value) {
        var previous = this.__path;
        this.__path = value;

        if (value !== previous) {
          this._initPathIfReady(value);
        }
      }
    }, {
      key: 'editable',
      get: function get() {
        return this.__editable;
      },
      set: function set(value) {
        var previous = this.__editable;

        if (!this.readonly) {
          this.__editable = value;

          if (value !== previous) {
            changed(this, 'editable', value);
          }
        }
      }
    }, {
      key: 'readonly',
      get: function get() {
        return this.__readonly;
      },
      set: function set(value) {
        var previous = this.__readonly;

        // Disable to allow editable to be set however we like
        this.__readonly = false;

        if (!value && previous === true) {
          this.editable = Simpla.getState('editable');
        } else if (value) {
          this.editable = false;
        }

        this.__readonly = value;
      }
    }, {
      key: 'loaded',
      get: function get() {
        return this.__loaded;
      }
    }, {
      key: '_loaded',
      set: function set(value) {
        var previous = this.__loaded;
        this.__loaded = value;

        if (value !== previous) {
          changed(this, 'loaded', value);
        }
      }
    }], [{
      key: 'observedAttributes',
      get: function get() {
        return ['path', 'editable', 'readonly', 'loaded'];
      }
    }]);

    return _class;
  }(Base);
};</script>
